/////////////
// GLOBALS //
/////////////
Texture2D grassTexture;
Texture2D grassAlphaTexture;

SamplerState SampleType;

cbuffer LightBuffer
{
	float4 ambientColor;
	float4 diffuseColor;
    float3 lightDirection;
	float padding;
	float3 cameraDirection;
	float padding1; 
};

BlendState AlphaBlendingOn
{
    BlendEnable[0] = TRUE;
    DestBlend = INV_SRC_ALPHA;
    SrcBlend = SRC_ALPHA;
};

struct PixelInputType
{
    float4 position : SV_POSITION;
	float2 tex : TEXCOORD0;
	float4 normal : NORMAL;
	float rand : RAND;
};

struct PsOutput
{
    float4 v4Color		: SV_Target;
    uint uCoverageMask	: SV_Coverage; 
};

PsOutput PsTransparencyAA( PixelInputType input )
{ 
    PsOutput output;
    output.uCoverageMask = 0x0;
    float4 v4Sample;
    float4 v4ColorBlend = float4( 0.0f, 0.0f, 0.0f, 0.0f );

    int MSAA_SAMPLES = 4;

	/*float2 v2MSAAOffsets[2] = 
	{ 
		float2(0.25, 0.25),    float2(-0.25, -0.25) 
	};*/
	float2 v2MSAAOffsets[4] = 
	{ 
		float2(-0.125, -0.375),    float2(0.375, -0.125),
		float2(-0.375,  0.125),    float2(0.125,  0.375)
	};
	/*float2 v2MSAAOffsets[8] = 
	{ 
		float2(0.0625, -0.1875),    float2(-0.0625,  0.1875),
		float2(0.3125,  0.0625),    float2(-0.1875, -0.3125),
		float2(-0.3125,  0.3125),   float2(-0.4375, -0.0625),
		float2(0.1875,  0.4375),    float2(0.4375, -0.4375)
	};*/


    // We need the texture address gradients in order to calulate the MSAA texturing offsets
    float2 v2DDX = ddx( input.tex );
    float2 v2DDY = ddy( input.tex );
    
	float g_fAlphaRef = 0.5f;

    // Loop through the samples    
    [unroll] for( int i = 0; i < MSAA_SAMPLES; ++i )
    {
        // Calculate texture offset
        float2 v2TexelOffset = v2MSAAOffsets[i].x * v2DDX + v2MSAAOffsets[i].y * v2DDY;
        
        // Sample the alpha texture
        v4Sample = grassAlphaTexture.Sample( SampleType, input.tex + v2TexelOffset );
        
		float alpha = (v4Sample.x + v4Sample.y + v4Sample.z) / 3.f;

        // Perform the alpha test
        if( ( alpha - g_fAlphaRef ) >= 0 )
        { 
            // Update the output coverage mask accordingly
            output.uCoverageMask |= ( uint(0x1) << i );
            
            // Perform a weighted sum of the color and alpha component of the passed sample
            v4ColorBlend.rgb += ( v4Sample.rgb * float3(alpha, alpha, alpha) );
            v4ColorBlend.a += alpha;
        }
    }
    
    // Average the color sum by the summed alpha
    v4ColorBlend.rgb /= v4ColorBlend.aaa;
    
    // Modulate by diffuse lighting value    
    output.v4Color = v4ColorBlend;// * input.v4Diffuse;
    
    return output;
}

float4 main( PixelInputType input ) : SV_TARGET
{
	float4 alpha = grassAlphaTexture.Sample(SampleType, input.tex);
	clip( (alpha < .5) ? -1 : 1 );

	float4 textureColor;
	float3 lightDir;
	float lightIntensity;

	PsOutput output;

	// Sample the pixel color from the texture using the sampler at this texture coordinate location.
    textureColor = grassTexture.Sample(SampleType, input.tex);
	float camDir = (cameraDirection.x+cameraDirection.y+cameraDirection.z)/3;

	static const float4 tint = {0.9,0.6,0.4,1};
	static const float4 lightPos = {0, 1, 0, 1};		// using up vec 
	static const float4 gold = {0.8549f, 0.43137f, 0, 1};
	static const float4 autumnTint = {0.8549f, 0.23137f, 0, 1};
	static const float4 skyBlue = {.502, .859, .933, 1};
	static const float4 greenGrass = {.502, .859, .433, 1};

	float4 normalu = input.normal;//normalize( input.normal );
	normalu =  dot( normalu, lightPos ); 

	float floorShade = (1.0-input.tex.y)*(1.0-input.tex.y) + 0.27;

	/////////////////////////////////////////
	// Autumn Grass
	//
	/*
	float texy = .25-input.tex.y;
	if( texy < 0 )
		texy = 0;
	float4 goldCoeff = lerp(float4(0,0,0,1), gold, pow(normalu,5) * float4(texy, texy, texy,1)*1.6);

	float4 finalColor = floorShade * textureColor;

	finalColor = finalColor * camDir * ( lerp( autumnTint, tint, input.rand ) );
		
	finalColor = lerp( finalColor+.045, goldCoeff, 1 - ( ( gold - goldCoeff ) / gold ) );
	*/
	/////////////////////////////////////////
	// Summer(blue sky) Grass
	//
	/*
	float texy = .25-input.tex.y;
	if( texy < 0 )
		texy = 0;
	float4 skyBlueCoeff = lerp(float4(0,0,0,1), skyBlue, pow(normalu,5) * float4(texy, texy, texy,1)*1.6);
	
	float4 finalColor = floorShade * textureColor;

	finalColor = finalColor * camDir * ( lerp( tint + .1, float4( 1, 1, 1, 1 ), input.rand ) );
		
	finalColor = lerp( finalColor+.005, skyBlueCoeff, 1 - ( ( skyBlue - skyBlueCoeff ) / skyBlue ) );
	*/

	/////////////////////////////////////////
	// Green Grass
	//
	/*
	float texy = .25-input.tex.y;
	if( texy < 0 )
		texy = 0;
	float4 greenGrassCoeff = lerp(float4(0,0,0,1), greenGrass, pow(normalu,5) * float4(texy, texy, texy,1)*1.6);
	
	float4 finalColor = floorShade * textureColor;

	finalColor = finalColor * camDir * ( lerp( tint + .1, float4( 1, 1, 1, 1 ), input.rand ) );
		
	finalColor = lerp( finalColor+.005, greenGrassCoeff, 1 - ( ( greenGrass - greenGrassCoeff ) / greenGrass ) );
	*/

	/////////////////////////////////////////
	// Green Grass with Autumn Tips
	//
	
	float texy = .25-input.tex.y;
	if( texy < 0 )
		texy = 0;
	float4 goldCoeff = lerp(float4(0,0,0,1), gold, pow(normalu,5) * float4(texy, texy, texy,1)*1.6);
	
	float4 finalColor = floorShade * textureColor;

	finalColor = finalColor * camDir * ( lerp( tint + .1, float4( 1, 1, 1, 1 ), input.rand ) );
		
	finalColor = lerp( finalColor, goldCoeff, 1 - ( ( gold - goldCoeff ) / gold ) );
	
    return float4( finalColor.x, finalColor.y, finalColor.z, alpha.x );
	
}

	//clip( ( alpha.r < .1f ) ? -1 : 1 );

	//output = PsTransparencyAA( input );

	//if(alpha.x <.08)alpha.x = 0;


	// Set the default output color to the ambient light value for all pixels.
    //color = ambientColor;

	// Invert the light direction for calculations.
    //lightDir = -lightDirection;

    // Calculate the amount of light on this pixel.
    //lightIntensity = saturate( dot( input.normal, lightDir ) );

	/*if(lightIntensity > 0.0f)
    {
        // Determine the final diffuse color based on the diffuse color and the amount of light intensity.
        color += ( diffuseColor * lightIntensity );
    }*/

    // Saturate the final light color.
    //color = saturate( color );

	// Multiply the texture pixel and the final light color to get the result.
    //color = ( color * textureColor ) * cameraDirection.x;
	//color = input.cameraDirection;

	//if( alpha.r == -1 ) clip( -1 );